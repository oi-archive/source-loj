{"title":"「IOI2018」高速公路收费","time_limit":1500,"memory_limit":268,"tags":["2018","IOI"],"operation":{"submit":"https://loj.ac/problem/2867#submit_code","submissions":"https://loj.ac/submissions?problem_id=2867","statistics":"https://loj.ac/problem/2867/statistics/fastest","testdata":"https://loj.ac/problem/2867/testdata","discussion":"https://loj.ac/discussion/problem/2867"},"statement":[{"title":"题目描述","type":"description","format":"markdown","require":["katex"],"content":"**在 LibreOJ 上，由于语言与交互库的限制，本题仅支持以下语言提交**：\r\n- C++ 11\r\n- C++ 17\r\n\r\n在日本，城市是用一个高速公路网络连接起来的。这个网络包含 $N$ 个城市和 $M$ 条高速公路。每条高速公路都连接着两个不同的城市。不会有两条高速公路连接相同的两个城市。城市的编号是从 $0$ 到 $N-1$，高速公路的编号则是从 $0$ 到 $M-1$。每条高速公路都可以双向行驶。你可以从任何一个城市出发，通过这些高速公路到达其他任何一个城市。\r\n\r\n使用每条高速公路都要收费。每条高速公路的收费都会取决于它的**交通状况**。交通状况或者为**顺畅**，或者为**繁忙**。当一条高速公路的交通状况为顺畅时，费用为 $A$ 日元（日本货币），而当交通状况为繁忙时，费用为 $B$ 日元。这里必有 $A\\lt B$。注意，$A$ 和 $B$ 的值对你是已知的。\r\n\r\n你有一部机器，当给定所有高速公路的交通状况后，它就能计算出在给定的交通状况下，在两个城市 $S$ 和 $T$（$S\\neq T$）之间旅行所需要的最小的高速总费用。\r\n\r\n然而，这台机器只是一个原型。所以 $S$ 和 $T$ 的值是固定的（即它已经被硬编码到机器中），但是你并不知道它们的值是什么。你的任务就是去找出 $S$ 和 $T$ 的值。为了找出答案，你打算先给机器设定几种交通状况，然后利用它输出的高速费用来推断出 $S$ 和 $T$。由于设定高速公路交通状况的代价很大，所以你并不想使用这台机器很多次。\r\n\r\n#### 实现细节\r\n你需要在开始包含 `highway.h` 库文件，并实现下面的过程：\r\n```cpp\r\nfind_pair(int N, int[] U, int[] V, int A, int B)\r\n```\r\n- `N`：城市的数量。\r\n- `U` 及 `V`：长度为 $M$ 的数组，其中 $M$ 为连接城市的高速公路的数量。对于每个 $i$（$0\\le i\\le M-1$），高速公路 $i$ 连接城市 `U[i]` 和 `V[i]`。\r\n- `A`：交通状况顺畅时高速公路的收费。\r\n- `B`：交通状况繁忙时高速公路的收费。\r\n- 对于每个测试样例，该过程会被调用恰好一次。\r\n- 注意，$M$ 为数组的长度，所有数组均为 `vector`。\r\n\r\n过程 `find_pair` 可以调用以下函数：\r\n```cpp\r\nint64 ask(int[] w)\r\n```\r\n- `w` 的长度必须为 $M$。 数组 `w` 描述高速公路的交通状况。\r\n- 对于每个 $i$（$0\\le i\\le M-1$），`w[i]` 表示高速公路 $i$ 的交通状况。`w[i]` 的值必须为 $0$ 或 $1$。\r\n  - `w[i] = 0` 表示高速公路 $i$ 的交通状况为顺畅。\r\n  - `w[i] = 1` 表示高速公路 $i$ 的交通状况为繁忙。\r\n- 该函数返回的是，在 `w` 所描述的交通状况下，在城市 $S$ 和 $T$ 之间旅行所需的最少总费用。\r\n- 该函数最多只能被调用 $100$ 次（对于每个测试样例）。\r\n\r\n`find_pair` 应调用以下过程来报告答案：\r\n```cpp\r\n​answer(int s, int t)\r\n```\r\n- `s` 和 `t` 的值必须为城市 $S$ 和 $T$（两者的先后次序并不重要）。\r\n- 该过程必须被调用恰好一次。\r\n\r\n如果不满足上面的条件，你的程序将被判为 `Wrong Answer`。否则，你的程序将被判为 `Accepted`，而你的得分将根据 `ask` 的调用次数来计算（参见子任务）。"},{"title":"输入格式","type":"input_format","format":"markdown","require":["katex"],"content":"评测程序示例将读取如下格式的输入：\r\n- 第一行：$N\\ M\\ A\\ B\\ S\\ T$\r\n- 第 $2+i$ 行（$0\\le i\\le M-1$）：$U[i]\\ V[i]$\r\n\r\n如果你的程序被判为 `Accepted`，评测程序示例将打印出 `Accepted: q`，这里的 `q` 为函数 `ask` 被调用的次数。\r\n\r\n如果你的程序被判为 `Wrong Answer`，它打印出 `Wrong Answer: MSG`。各类 `MSG` 的含义如下：\r\n- `answered not exactly once`：过程 `answer` 没有被调用恰好一次。\r\n- `w is invalid`：传给函数 `ask` 的 `w` 的长度不是 $M$，或者某个 $i$（$0\\le i\\le M-1$）上的 `w[i]` 既不是 $0$ 也不是 $1$。\r\n- `more than 100 calls to ask`：函数 `ask` 的调用次数超过 $100$ 次。\r\n- `{s, t} is wrong`：调用 `answer` 时的 `s` 和 `t` 是错的。\r\n"},{"title":"样例","type":"example","format":"markdown","require":["katex"],"content":"设 $N=4,M=4,U=[0,0,0,1],V=[1,2,3,2],A=1,B=3,S=1$ 和 $T=3$。\r\n\r\n评测程序调用 `find_pair(4, [0, 0, 0, 1], [1, 2, 3, 2], 1, 3)`。\r\n\r\n![highway.png](https://i.loli.net/2019/02/07/5c5bef648c5e0.png)\r\n\r\n上图中，编号为 $i$ 的边对应高速公路 $i$。其中一些对 `ask` 的可能调用和对应的返回值如下表所示：\r\n\r\n|调用|返回值|\r\n|:-:|:-:|\r\n|`ask([0, 0, 0, 0])`|$2$|\r\n|`ask([0, 1, 1, 0])`|$4$|\r\n|`ask([1, 0, 1, 0])`|$5$|\r\n|`ask([1, 1, 1, 1])`|$6$|\r\n\r\n对于函数调用 `ask([0, 0, 0, 0])`，所有高速公路的交通状况均为顺畅，因此每条高速公路的费用都是 $1$。从城市 $S=1$ 到城市 $T=3$ 的费用最低的路径就是 $1\\to 0\\to 3$。这条路径的总费用等于 $2$。因此，这个函数的返回值就是 $2$。\r\n\r\n对于一个正确的解答来说，过程 `find_pair` 应调用 `answer(1, 3)` 或 `answer(3, 1)`。"},{"title":"数据范围与提示","type":"limit_and_hint","format":"markdown","require":["katex"],"content":"对于全部数据：\r\n- $2\\le N\\le 9\\times 10^4,1\\le M\\le 1.3\\times 10^5,1\\le A\\lt B\\le 10^9$\r\n- 对于每一个 $0\\le i\\le M-1$\r\n  - $0\\le U[i],V[i]\\le N-1$\r\n  - $U[i]\\neq V[i]$\r\n- 保证数据无重边。\r\n- 你可以从任何一个城市出发，通过高速公路到达其他任何一个城市。\r\n- $0\\le S,T\\le N-1,S\\neq T$\r\n\r\n在本题中，评测程序不是适应性的。意思是说，在评测程序开始运行的时候 $S$ 和 $T$ 就固定下来，而且不依赖于你的程序所做的询问。\r\n\r\n#### 子任务\r\n1. (5 分) $S$ 或 $T$ 有一个是 $0$，$N\\le 100,M=N-1$\r\n2. (7 分) $S$ 或 $T$ 有一个是 $0$，$M=N-1$\r\n3. (6 分) $M=N-1,U[i]=i,V[i]=i+1\\ (0\\le i\\le M-1)$\r\n4. (33 分) $M=N-1$\r\n5. (18 分) $A=1,B=2$\r\n6. (31 分) 没有附加限制。\r\n \r\n假设你的程序被判为 `Accepted`，而且函数 `ask` 调用了 $X$ 次。你在该测试样例上的得分 $P$，取决于对应子任务的编号，其计算如下：\r\n- 子任务 1：$P=5$\r\n- 子任务 2：如果 $X\\le 60$，$P=7$。否则 $P=0$。\r\n- 子任务 3：如果 $X\\le 60$，$P=6$。否则 $P=0$。\r\n- 子任务 4：如果 $X\\le 60$，$P=33$。否则 $P=0$。\r\n- 子任务 5：如果 $X\\le 52$，$P=18$。否则 $P=0$。\r\n- 子任务 6：\r\n  - 如果 $X\\le 50$，$P=31$。\r\n  - 如果 $51\\le X\\le 52$，$P=21$。\r\n  - 如果 $53\\le X$，$P=0$。\r\n\r\n注意，你在每个子任务上的得分，等于你在该子任务中所有测试样例上的最低得分。"}]}