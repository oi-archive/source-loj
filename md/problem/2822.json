{"title":"「BalticOI 2014 Day1」警察与强盗","time_limit":1500,"memory_limit":256,"tags":["2014","BalticOI","交互题","Special Judge"],"operation":{"submit":"https://loj.ac/problem/2822#submit_code","submissions":"https://loj.ac/submissions?problem_id=2822","statistics":"https://loj.ac/problem/2822/statistics/fastest","testdata":"https://loj.ac/problem/2822/testdata","discussion":"https://loj.ac/discussion/problem/2822"},"statement":[{"title":"题目描述","type":"description","format":"markdown","require":["katex"],"content":"**本题译自 [BalticOI 2014](http://www.boi2014.lmio.lt/tasks.html) Day1 T1「[Cop and Robber](http://www.boi2014.lmio.lt/tasks/coprobber-en.pdf)」**\r\n\r\n**本题暂时只能支持 C++ / C++ 11 语言提交，需引入 `coprobber.h` 头文件方可正常评测。**\r\n\r\nBytemore 的犯罪率又创历史新高。在所有的违法行为中，抢劫天天发生。然而当每次抢劫发生时，总是只有一个巡警孤身一人在街角的狭窄小巷之间追捕强盗。不幸的是，往往是强盗打赢这场追逐战，因为这些老奸巨猾的强盗早已对这个城市了如指掌。\r\n\r\nBytemore 市公安部门（英文缩写为 BCPD）正在组织一场最高会议来减少犯罪。其中一种可行的解决方案是在追捕盗贼时使用计算机远程协助警察。为此，BCPD 制作了一份精细的城市地图。现在他们需要一个~~大佬~~计算机程序来制定追捕策略。\r\n\r\n警察追捕强盗的问题可以如下模式化：\r\n\r\n 1. 这名警察会选择一个街角巡逻。\r\n\r\n 2. 强盗会选择一个街角施行抢劫（他知道警察的位置）。从这时开始，我们总是假设警察与强盗互相知道对方的位置。\r\n\r\n 3. 警察所可以进行的移动包括转移到另一个相邻的街角（即从一条小巷转移到另一条与之相连接的小巷）或等待（即不动）。\r\n\r\n 4. 强盗所可以进行的移动同样包括转移到另一个相邻的街角。请注意，相比警察，强盗并不能等待，因为逃跑是他们的本能。\r\n\r\n 5. 警察与强盗会一直轮流进行动作（从警察开始）直到以下一种情况发生：\r\n\r\n   - 强盗能够一直躲避警察，使得强盗能够逃脱；\r\n\r\n   - 他们其中任意一个作出移动之后在同一个街角相遇。在这种情况下，警察抓住了强盗。\r\n\r\n你需要写一个程序，它对于给定的地图，能够确定警察是否有可能抓到强盗，且若果可以，输出警察抓到强盗时进行的移动数量。\r\n\r\n你的程序须假设强盗总是做出最优方案。\r\n\r\n你需要写两个函数与交互器进行交互，函数原型分别为：\r\n\r\n```cpp\r\nint start(int N, bool A[MAX_N][MAX_N]);\r\nint nextMove(int R);\r\n```\r\n\r\n - 其中 `start(N, A)`传入以下参数：\r\n\r\n   - $N$——街角的数量（街角以 $0$ 到 $N - 1$ 编号）；\r\n\r\n   - $A$——一个二维数组描述小巷：对于所有的 $0 \\le i,\\,j \\le N-1$，若 $i$ 与 $j$ 不连通，则 $A[i,j]=\\texttt{false}$，否则 $A[i,j]=\\texttt{true}$\r\n\r\n    所有小巷都是双向的（即对于所有 $i$ 和 $j$，$A[i,j]=A[j,i]$），并且不会出现自环（即对于所有 $i$，$A[i,i]=\\texttt{false}$）。此外，你可以假设警察总能从其他街角通过小巷到达一个街角。\r\n\r\n 如果警察可能在由参数描述的地图上抓到强盗，函数`start`应该返回警察与强盗相遇的街角编号。否则返回 $-1$。\r\n\r\n - 而 `nextMove(R)` 传入参数 $R$，表示当前强盗的所在的街角编号。该函数应返回这次移动之后警察所在的街角编号。\r\n\r\n函数 `start` 必定会在第一次调用函数 `nextMove` 调用一次。如果 `start` 返回了 $-1$，那么 `nextMove` 将不会被调用。否则，`nextMove` 会被反复调用直到追捕行动结束。更确切地说，只要满足以下情况之一，程序必须终止：\r\n\r\n - `nextMove` 返回了一个不合法的移动；\r\n\r\n - 强盗能够一直躲避警察；\r\n\r\n - 强盗被抓住了。\r\n\r\n**您可以参考附加文件中的 `coprobber.cpp` 的格式书写代码。**\r\n"},{"title":"输入格式","type":"input_format","format":"markdown","require":["katex"],"content":"第一行，一个整数 $N$，表示街角的个数。\r\n\r\n以下 $N$ 行，包含一个邻接矩阵 $A$。  \r\n其中每行包含 $N$ 个数字，要么是 $0$ 要么是 $1$。\r\n\r\n如果警察可以抓到强盗，下一行为 $1$，否则为 $0$。\r\n\r\n如果上一行为 $1$，以下将会有 $N$ 行，描述强盗的策略。  \r\n每行 $N+1$ 个 $[0,N-1]$ 之间的整数。  \r\n第 $r$ 行第 $c$ 列（其中 $c < N$）的整数对应的情况下为强盗的回合，警察在街角 $r$ 而强盗已经移动到街角 $c$。  \r\n主对角线将被忽略。  \r\n第 $r$ 行的最后一个整数表示如果警察从街角 $r$ 开始则强盗开始的街角为该数。\r\n"},{"title":"样例","type":"example","format":"markdown","require":["katex"],"content":"我们来看看以下示例。\r\n\r\n如图所示，在这个例子中从任意一个街角开始追捕对于警察来说都是好事。如果他从街角 $0$ 开始，在第一次移动中他可以待在原地等待强盗自投罗网。如果他从其他街角开始，他也可以一直等待直到强盗跑向街角 $0$，然后前往街角 $0$ 逮捕他。\r\n\r\n![](https://i.loli.net/2018/08/18/5b77bab1814ea.png)\r\n\r\n以下是示例会话（引入 `grader.h` 后将会自动调用）：\r\n\r\n|函数调用|返回值|\r\n|:-:|:-:|\r\n|`start(4, [[0, 1, 1, 1], [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0]]) `|$3$|\r\n|`nextMove(1)`|$3$|\r\n|`nextMove(0)`|$0$|\r\n\r\n注意：为了简洁起见，以上对于 `start` 的调用传参中，以 $0$ 代替 `false`，以 $1$ 代替 `true`。"},{"title":"数据范围与提示","type":"limit_and_hint","format":"markdown","require":["katex"],"content":"|子任务编号|分数|数据范围|附加条件|\r\n|:-:|:-:|:-:|:-:|\r\n|1|16|$1 \\le N \\le 500$|对于每两个街角，只有一条路线可以互相到达。|\r\n|2|14|$1 \\le N \\le 500$|街角与小巷形成的网络为网格形结构。网格至少有两行且街角的编号情况如下图所示。|\r\n|3|30|$2 \\le N \\le 100$|无|\r\n|4|40|$2 \\le N \\le 500$|无|\r\n![](https://i.loli.net/2018/08/18/5b77c7246106b.png)\r\n\r\n你的函数实现须满足下述要求：\r\n\r\n 1. 确定警察能否抓到强盗；\r\n\r\n 2. 如果警察有可能抓到强盗的话，表示警察可以通过移动抓到强盗。\r\n\r\n在子任务 $1$ 与 $2$ 中，你的解决方案应该满足以上要求才能拿到所有分数。  \r\n在子任务 $3$ 与 $4$ 中，若你的解决方案只满足要求 $1$，可以拿到 $30\\%$ 的子任务分数。如果你的程序只打算拿部分分，则可以通过输出无效的移动来终止程序（例如，使 `nextMove` 返回 $-1$）。"}]}