{"title":"「IOI2020」嘉年华奖券","time_limit":2000,"memory_limit":1024,"tags":["IOI","2020","贪心"],"operation":{"submit":"https://loj.ac/problem/3366#submit_code","submissions":"https://loj.ac/submissions?problem_id=3366","statistics":"https://loj.ac/problem/3366/statistics/fastest","testdata":"https://loj.ac/problem/3366/testdata","discussion":"https://loj.ac/discussion/problem/3366"},"statement":[{"title":"题目描述","type":"description","format":"markdown","require":["katex"],"content":"注意：**在 LibreOJ 上，由于语言限制，目前只支持以下语言的提交：**\r\n- C++ 11\r\n- C++ 11 (Clang)\r\n- C++ 11 (NOI)\r\n- C++ 17\r\n- C++ 17 (Clang)\r\n\r\nRingo 正在参加在新加坡举办的⼀个嘉年华活动。他的口袋⾥装有⼀些奖券，这些奖券可以在嘉年华的游戏展位使用。假设共有 $n$ 种颜色的奖券，每张奖券涂上了其中的⼀种颜色并且印上了⼀个非负整数。不同奖券上的数字可能相同。依据嘉年华活动的规则要求，$n$ 保证是偶数。\r\n\r\nRingo 每种颜色的奖券有 $m$ 张，也就是说他共有 $n\\cdot m$ 张奖券。其中，第 $i$ 种颜色对应的第 $j$ 张奖券上印的数字为 $x_{i,j}$（$0\\le i\\le n-1$ 且 $0\\le j\\le m - 1$）。\r\n\r\n⼀次奖券游戏要进⾏ $k$ 轮，轮次的序号从 $0$ 到 $k-1$。每⼀轮按照下⾯的⽅式进⾏：\r\n\r\n- ⾸先，Ringo 从每种颜⾊的奖券中各选出⼀张奖券，形成⼀个 $n$ 张奖券的**集合**。\r\n\r\n- 随后，游戏负责⼈记录下这个集合中奖券上的数字 $a_0, a_1, \\dots, a_{n-1}$。不需要考虑这 $n$ 个整数的顺序。\r\n\r\n- 接下来，游戏负责⼈从⼀个幸运抽奖箱中抽取⼀张特殊卡⽚，上⾯印有整数 $b$。\r\n\r\n- 对于上述集合中每⼀个奖券上的数字 $a_i(0\\le i \\le n-1)$，游戏负责⼈会计算 $a_i$ 和 $b$ 的差的绝对值。让 $S$ 代表这 $n$ 个差的绝对值之和。\r\n\r\n- 所得到的数字 $S$ 就是 Ringo 本轮能够获得的奖励数额。\r\n\r\n- ⼀轮游戏结束后，本轮集合中的奖券全部被丢弃，不会在未来的轮次所使⽤。\r\n\r\n当 $k$ 轮游戏结束后，Ringo 会丢弃口袋中的所有奖券。\r\n\r\n通过仔细观察，Ringo 发现这个奖券游戏被操控了！实际上，幸运抽奖箱⾥⾯内置了⼀台打印机。在每⼀轮，游戏负责⼈⾸先找到⼀个能够最小化当前轮次游戏奖励的整数 $b$，然后将该数字打印在他所抽取的特殊卡⽚上。\r\n\r\n知道了这些信息之后，Ringo 想要设计每轮游戏中的奖券分配⽅案，使得 $k$ 轮游戏中获得的总体奖励数额之和最⼤。\r\n\r\n#### 实现细节\r\n\r\n你需要实现下⾯这个函数：\r\n\r\n```cpp\r\nlong long find_maximum(int k, std::vector<std::vector<int>> x)\r\n```\r\n\r\n- $k$：游戏的轮数。\r\n\r\n- $x$：⼀个 $n\\times m$ 的数组，记录了奖券上的数字。每种颜⾊的奖券按照上⾯的数字⾮递减顺序排序。\r\n\r\n- 这个函数只会被调⽤⼀次。\r\n\r\n- 这个函数应该只调⽤⼀次函数 `allocate_tickets`（参⻅下⾯的内容），它描述了 $k$ 轮游戏中的奖券分配⽅案，每⼀轮对应⼀个奖券集合。奖券的分配⽅案应该使得所获奖励数额之和达到最⼤。\r\n\r\n- 这个函数需要返回能够获得的最⼤的奖励数额之和。\r\n\r\n函数 `allocate_tickets` 按照如下的⽅式进⾏定义：\r\n\r\n```cpp\r\nvoid allocate_tickets(std::vector<std::vector<int>> s)\r\n```\r\n\r\n- $s$：⼀个 $n\\times m$ 的数组。如果第 $i$ 种颜⾊的第 $j$ 张奖券如果被分配到了第 $r$ 轮游戏，那么 $s_{i,j}$ 的值应该为 $r$；如果未被使⽤，应该为 $-1$。\r\n\r\n- 对于 $0\\le i\\le n-1$，在 $s_{i,0}, s_{i,1}, \\dots, s_{i,m-1}$ 中，每个值 $0, 1, \\dots, k - 1$ 必须只出现⼀次，而其他元素应该为 $-1$。\r\n\r\n- 如果存在多种奖券分配⽅案能够达到最优的奖励数值，可以给出其中任何⼀种最优⽅案。\r\n\r\n#### 评测程序⽰例\r\n\r\n评测程序示例按照下面的格式读入数据：\r\n\r\n- 第 $1$ ⾏：$n\\ m\\ k$\r\n- 第 $2 + i$ ⾏（$0\\le i\\le n-1$）：$x_{i, 0}\\ x_{i,1}\\ \\dots\\ x_{i,m-1}$\r\n\r\n评测程序⽰例按照下⾯的格式打印你的答案：\r\n\r\n- 第 $1$ ⾏：`find_maximum` 的返回值\r\n- 第 $2 + i$ ⾏（$0\\le i\\le n-1$）：$s_{i, 0}\\ s_{i,1}\\ \\dots\\ s_{i,m-1}$\r\n"},{"title":"样例","type":"example","format":"markdown","require":["katex"],"content":"#### 样例输入 1\r\n\r\n```plain\r\n2 3 2\r\n0 2 5\r\n1 1 3\r\n```\r\n\r\n#### 样例输出 1\r\n\r\n```plain\r\n7\r\n0 -1 1\r\n-1 1 0\r\n```\r\n\r\n#### 样例解释 1\r\n\r\n考虑下⾯的函数调⽤：\r\n\r\n```cpp\r\nfind_maximum(2, [[0, 2, 5],[1, 1, 3]])\r\n```\r\n\r\n这意味着：\r\n- 游戏共进⾏ $k=2$ 轮；\r\n- 第 $0$ 种颜⾊奖券上的整数数字分别是 $0, 2$ 和 $5$；\r\n- 第 $1$ 种颜⾊奖券上的整数数字分别是 $1, 1$ 和 $3$；\r\n\r\n⼀种能够获得最优奖励数值的分配⽅案是：\r\n\r\n- 在第 $0$ 轮，Ringo 选择第 $0$ 种颜⾊的第 $0$ 张奖券（印有整数 $0$）和第 $1$ 种颜⾊的第 $2$ 张奖券（印有整数$3$）。本轮获得的最小奖励数额是 $3$。例如，游戏负责⼈可以选择 $b=1$：$|1-0| + |1-3| = 1+2 = 3$。\r\n\r\n- 在第 $1$ 轮，Ringo 选择第 $0$ 种颜⾊的第 $2$ 张奖券（印有整数 $5$）和第 $1$ 种颜⾊的第 $1$ 张奖券（印有整数 $1$）。本轮能够获得的最小奖励是 $4$。例如，游戏负责⼈可以选择 $b=3$：$|3-1|+|3-5|=2+2=4$。\r\n\r\n- 因此，本次游戏两轮的奖励之和为 $3+4=7$。\r\n\r\n为了给出这个分配⽅案，函数 `find_maximum` 应该按照如下⽅式调⽤ `allocate_tickets`：\r\n\r\n- `allocate_tickets([[0, -1, 1], [-1, 1, 0]])`\r\n\r\n最终，函数 `find_maximum` 应该返回数字 $7$。\r\n\r\n#### 样例输入 2\r\n\r\n```plain\r\n4 2 1\r\n5 9\r\n1 4\r\n3 6\r\n2 7\r\n```\r\n\r\n#### 样例输出 2\r\n\r\n```plain12\r\n12\r\n-1 0\r\n0 -1\r\n0 -1\r\n-1 0\r\n```\r\n\r\n#### 样例解释 2\r\n\r\n考虑下⾯的函数调⽤：\r\n\r\n```cpp\r\nfind_maximum(1, [[5, 9], [1, 4], [3, 6], [2, 7]])\r\n```\r\n\r\n这意味着：\r\n\r\n- 游戏只进⾏⼀轮；\r\n- 第 $0$ 种颜⾊奖券上的数字分别是 $5$ 和 $9$；\r\n- 第 $1$ 种颜⾊奖券上的数字分别是 $1$ 和 $4$；\r\n- 第 $2$ 种颜⾊奖券上的数字分别是 $3$ 和 $6$；\r\n- 第 $3$ 种颜⾊奖券上的数字分别是 $2$ 和 $7$；\r\n\r\n⼀种能够获得最优奖励的分配⽅案是：\r\n\r\n- 在第 $0$ 轮，Ringo 选择第 $0$ 种颜⾊的第 $1$ 张奖券（印有整数 $9$） ，第 $1$ 种颜⾊的第 $0$ 张奖券（印有整数 $1$），第 $2$ 种颜⾊的第 $0$ 张奖券（印有整数 $3$），第 $3$ 种颜⾊的第 $1$ 张奖券（印有整数 $7$）。本轮能够获得的最小奖励是 $12$。例如，游戏负责⼈可以选择 $b=3$：\r\n\r\n$$\r\n|3-9| + |3-1| + |3-3| + |3-7| = 6 + 2 + 0 + 4 = 12\r\n$$\r\n\r\n为了给出这个分配⽅案，函数 `find_maximum` 应该按照如下⽅式调⽤ `allocate_tickets`：\r\n\r\n- `allocate_tickets([[-1, 0], [0, -1], [0, -1], [-1, 0]])`\r\n\r\n最终，函数 `find_maximum` 应该返回数字 $12$。"},{"title":"数据范围与提示","type":"limit_and_hint","format":"markdown","require":["katex"],"content":"对于 $100\\%$ 的数据，保证：\r\n\r\n- $2\\le n\\le 1500$ 且 $n$ 为偶数\r\n- $1\\le k\\le m\\le 1500$\r\n- $0\\le x_{i,j}\\le 10^9$（对于所有的 $0\\le i\\le n-1$ 且 $0\\le j\\le m-1$）\r\n- $x_{i,j-1}\\le x_{i,j}$（对于所有的 $0\\le i\\le n-1$ 且 $1\\le j\\le m-1$）\r\n\r\n| 子任务 |                           附加限制                           | 分值  |\r\n| :----: | :----------------------------------------------------------: | :---: |\r\n|  $1$   |                            $m=1$                             | $11$  |\r\n|  $2$   |                            $k=1$                             | $16$  |\r\n|  $3$   | $0\\le x_{i,j}\\le 1$（对于所有的 $0\\le i\\le n-1$ 且 $0\\le j\\le m-1$） | $14$  |\r\n|  $4$   |                            $k=m$                             | $14 $ |\r\n|  $5$   |                         $n,m\\le 80$                          | $12$  |\r\n|  $6$   |                         $n,m\\le 300$                         | $23$  |\r\n|  $7$   |                         没有其他限制                         | $10$  |\r\n\r\n"}]}