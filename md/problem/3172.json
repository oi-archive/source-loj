{"title":"「IOI2017」大奖","time_limit":1000,"memory_limit":1024,"tags":["2017","IOI","分治","交互题"],"operation":{"submit":"https://loj.ac/problem/3172#submit_code","submissions":"https://loj.ac/submissions?problem_id=3172","statistics":"https://loj.ac/problem/3172/statistics/fastest","testdata":"https://loj.ac/problem/3172/testdata","discussion":"https://loj.ac/discussion/problem/3172"},"statement":[{"title":"题目描述","type":"description","format":"markdown","require":["katex"],"content":"**很抱歉，由于技术局限，本题只支持各版本 `C++`。**\r\n\r\n**提示：请参考选手目录下的示例代码，`int[]` 的实际实现方式为 `std::vector<int>`。**\r\n\r\n「大奖」是一个家喻户晓的 TV 游戏节目。这次你很幸运地进入到最后一轮。已知编号从 $0$ 到 $n-1$ 的 $n$ 个盒子从左到右排成一行，你就站在这排盒子的前面。每个盒子里面放有一个奖品，必须打开盒子才能看到是什么奖品。已知有 $v \\ge 2$ 种不同类型的奖品。这 $v$ 种类型按照奖品价值的降序从 $1$ 到 $v$ 排列。\r\n\r\n类型 $1$ 的奖品是一块钻石，价值最高。所有盒子加起来刚好只有一块钻石。类型 $v$ 的奖品是一块棒棒糖，价值最低。为使得游戏更加激动人心，相对便宜的奖品数量远比价值昂贵的奖品数量要多。更具体一点，对于满足 $2 \\le t \\le v$ 的所有 $t$，我们有：如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。\r\n\r\n你的目标是赢得那块钻石。在游戏结束时，你必须打开一个盒子并收取盒子内的奖品。在选择要打开的盒子之前，你可以向节目主持人 Rambod 提一些问题。在每一个问题中，你选择就某个 $i$ 号盒子进行提问。Rambod 将给你一个包含两个整数的数组 $a$ 作为回答。这两个整数的意义如下：\r\n- 在 $i$ 号盒子左面的盒子中，刚好有 $a[0]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。\r\n- 在 $i$ 号盒子右面的盒子中，刚好有 $a[1]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。\r\n\r\n例如，假设 $n=8$，在你的问题中，你选择就 $2$ 号盒子进行提问。Rambod 的回答是 $a=[1, 2]$。这个回答的意义是：\r\n- $0$ 号盒子和 $1$ 号盒子中恰好有一个盒子中的奖品比 $2$ 号盒子中的奖品更贵。\r\n- 在 $3,4,\\ldots,7$ 号盒子中恰好有 $2$ 个盒子中的奖品比 $2$ 号盒子中的奖品更贵。\r\n\r\n你的任务就是通过问少量的问题找出包含钻石的盒子。\r\n\r\n#### 实现细节\r\n\r\n你应当实现如下函数段:\r\n\r\n```cpp\r\nint find_best(int n)\r\n```\r\n- 此函数只被评测程序调用仅一次。\r\n- $n$：盒子的数量.\r\n- 你实现的这个函数应该返回装有钻石的盒子编号，即，唯一的整数 $d~(0 \\le d \\le n-1)$ 使得 $d$ 号盒子放有类型为 $1$ 的奖品。\r\n\r\n上述函数可以调用下列函数:\r\n\r\n```cpp\r\nint[] ask(int i)\r\n```\r\n- $i$：你在询问时选择的盒子编号。$i$ 的数值必须介于 $0$ 和 $n-1$ 之间（含）。\r\n- 这个函数返回包含 $2$ 个元素的数组 $a$。其中，$a[0]$ 是在 $i$ 号盒子的左面，奖品比 $i$ 号盒子的奖品价值更高的盒子数目。而 $a[1]$ 则是在 $i$ 号盒子右面，奖品比 $i$ 号盒子的奖品价值更高的盒子数目。\r\n\r\n#### 例子\r\n\r\n评测工具将做如下函数调用:\r\n\r\n```cpp\r\nfind_best(8)\r\n```\r\n\r\n这里有 $n=8$ 个盒子。假定奖品类型为 $[3, 2, 3, 1, 3, 3, 2, 3]$。对函数 `ask` 的所有可能的调用以及相应的返回值列出如下：\r\n- `ask(0)` 返回 $[0, 3]$\r\n- `ask(1)` 返回 $[0, 1]$\r\n- `ask(2)` 返回 $[1, 2]$\r\n- `ask(3)` 返回 $[0, 0]$\r\n- `ask(4)` 返回 $[2, 1]$\r\n- `ask(5)` 返回 $[2, 1]$\r\n- `ask(6)` 返回 $[1, 0]$\r\n- `ask(7)` 返回 $[3, 0]$\r\n\r\n在这个例子中, 钻石放在 $3$ 号盒子里。所以函数 `find_best` 应该返回 $3$。\r\n\r\n![IOI2017-prize-desc.png](https://loj-img.upyun.menci.memset0.cn/2019/07/27/5d3c5f6ee8d3c.png)\r\n\r\n上图阐释了这个例子。图中上半部分给出了每个盒子中奖品的类型。图中的下半部分阐释了询问 `ask(2)`。做了标记（打$\\surd$）的盒子中装有比 $2$ 号盒子的奖品价值更高的奖品。\r\n\r\n#### 限制\r\n- $3 \\le n \\le 200000$\r\n- 每个盒子中奖品的类型介于 $1$ 和 $v$ 之间（含）.\r\n- 类型 $1$ 的奖品恰有一个。\r\n- 对于所有 $2 \\le t \\le v$，如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。\r\n\r\n#### 子任务与评分\r\n\r\n在某些测试数据中，评测工具的行为是自适应的。这意味着在这些测试数据中评测工具并没有一个固定的奖品序列。取而代之的是，由评测工具给出的答案可能依赖于你的程序问过的问题。评测工具的回答方式可以保证，在每次回答之后，至少有一个奖品序列与到目前为止给出的所有回答都不冲突。\r\n\r\n1.（$20$ 分）恰好有 $1$ 个钻石和 $n-1$ 个棒棒糖（所以，$v=2$）。你可以调用函数 `ask` 最多 $10000$ 次。\r\n\r\n2.（$80$ 分）没有附加限制。\r\n\r\n在子任务 $2$ 中你可以获得部分分。令 $q$ 是在这个子任务的所有测试数据上函数 `ask` 被调用的最大次数，那么你在这个子任务上的得分将按照下表计算：\r\n\r\n|问题|得分|\r\n|:-:|:-:|\r\n|$10000<q$|$0$ (Wrong Answer)|\r\n|$6000<q\\le10000$|$70$|\r\n|$5000<q\\le6000$|$80-(q-5000)/100$|\r\n|$q\\le5000$|$80$|\r\n\r\n#### 评测工具示例\r\n\r\n评测工具的这个示例不是自适应的。取而代之的是，它只是读取并使用一个固定的奖品类型的数组 $p$。对于所有的 $0 \\le b \\le n-1$，$b$ 号盒子中的奖品类型将由 $p[b]$ 给出。评测工具示例期望的输入格式如下：\r\n\r\n- 第 $1$ 行：$n$\r\n- 第 $2$ 行：$p[0]~p[1]~\\cdots~p[n-1]$\r\n\r\n评测工具示例输出单独一行，其中包含 `find_best` 的返回值以及调用函数 `ask` 的次数。"}]}